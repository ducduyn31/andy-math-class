# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Node {
    "Retrieves a record by `ID`"
    nodeId: ID!
}

"The root type for creating and mutating data"
type Mutation {
    "Deletes zero or more records from the `answer` collection"
    deleteFromanswerCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: answerFilter
    ): answerDeleteResponse!
    "Deletes zero or more records from the `books` collection"
    deleteFrombooksCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: booksFilter
    ): booksDeleteResponse!
    "Deletes zero or more records from the `chapters` collection"
    deleteFromchaptersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chaptersFilter
    ): chaptersDeleteResponse!
    "Deletes zero or more records from the `chapters_select_state` collection"
    deleteFromchapters_select_stateCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chapters_select_stateFilter
    ): chapters_select_stateDeleteResponse!
    "Deletes zero or more records from the `filter_states` collection"
    deleteFromfilter_statesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: filter_statesFilter
    ): filter_statesDeleteResponse!
    "Deletes zero or more records from the `question_images` collection"
    deleteFromquestion_imagesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: question_imagesFilter
    ): question_imagesDeleteResponse!
    "Deletes zero or more records from the `questions` collection"
    deleteFromquestionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: questionsFilter
    ): questionsDeleteResponse!
    "Deletes zero or more records from the `user_books_assignation` collection"
    deleteFromuser_books_assignationCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: user_books_assignationFilter
    ): user_books_assignationDeleteResponse!
    "Adds one or more `answer` records to the collection"
    insertIntoanswerCollection(objects: [answerInsertInput!]!): answerInsertResponse
    "Adds one or more `books` records to the collection"
    insertIntobooksCollection(objects: [booksInsertInput!]!): booksInsertResponse
    "Adds one or more `chapters` records to the collection"
    insertIntochaptersCollection(objects: [chaptersInsertInput!]!): chaptersInsertResponse
    "Adds one or more `chapters_select_state` records to the collection"
    insertIntochapters_select_stateCollection(objects: [chapters_select_stateInsertInput!]!): chapters_select_stateInsertResponse
    "Adds one or more `filter_states` records to the collection"
    insertIntofilter_statesCollection(objects: [filter_statesInsertInput!]!): filter_statesInsertResponse
    "Adds one or more `question_images` records to the collection"
    insertIntoquestion_imagesCollection(objects: [question_imagesInsertInput!]!): question_imagesInsertResponse
    "Adds one or more `questions` records to the collection"
    insertIntoquestionsCollection(objects: [questionsInsertInput!]!): questionsInsertResponse
    "Adds one or more `user_books_assignation` records to the collection"
    insertIntouser_books_assignationCollection(objects: [user_books_assignationInsertInput!]!): user_books_assignationInsertResponse
    "Updates zero or more records in the `answer` collection"
    updateanswerCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: answerFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: answerUpdateInput!
    ): answerUpdateResponse!
    "Updates zero or more records in the `books` collection"
    updatebooksCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: booksFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: booksUpdateInput!
    ): booksUpdateResponse!
    "Updates zero or more records in the `chapters` collection"
    updatechaptersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chaptersFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: chaptersUpdateInput!
    ): chaptersUpdateResponse!
    "Updates zero or more records in the `chapters_select_state` collection"
    updatechapters_select_stateCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chapters_select_stateFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: chapters_select_stateUpdateInput!
    ): chapters_select_stateUpdateResponse!
    "Updates zero or more records in the `filter_states` collection"
    updatefilter_statesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: filter_statesFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: filter_statesUpdateInput!
    ): filter_statesUpdateResponse!
    "Updates zero or more records in the `question_images` collection"
    updatequestion_imagesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: question_imagesFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: question_imagesUpdateInput!
    ): question_imagesUpdateResponse!
    "Updates zero or more records in the `questions` collection"
    updatequestionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: questionsFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: questionsUpdateInput!
    ): questionsUpdateResponse!
    "Updates zero or more records in the `user_books_assignation` collection"
    updateuser_books_assignationCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: user_books_assignationFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: user_books_assignationUpdateInput!
    ): user_books_assignationUpdateResponse!
    "Updates zero or more records in the `users` collection"
    updateusersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: usersFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: usersUpdateInput!
    ): usersUpdateResponse!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

"The root type for querying data"
type Query {
    "A pagable collection of type `answer`"
    answerCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: answerFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [answerOrderBy!]
    ): answerConnection
    "A pagable collection of type `books`"
    booksCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: booksFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [booksOrderBy!]
    ): booksConnection
    "A pagable collection of type `chapters`"
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    "A pagable collection of type `chapters_select_state`"
    chapters_select_stateCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chapters_select_stateFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chapters_select_stateOrderBy!]
    ): chapters_select_stateConnection
    "A pagable collection of type `filter_states`"
    filter_statesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: filter_statesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [filter_statesOrderBy!]
    ): filter_statesConnection
    "Retrieve a record by its `ID`"
    node(
        "The record's `ID`"
        nodeId: ID!
    ): Node
    "A pagable collection of type `question_images`"
    question_imagesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: question_imagesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [question_imagesOrderBy!]
    ): question_imagesConnection
    "A pagable collection of type `questions`"
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
    "A pagable collection of type `user_books_assignation`"
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
    "A pagable collection of type `users`"
    usersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: usersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [usersOrderBy!]
    ): usersConnection
}

type answer implements Node {
    created_at: Datetime
    id: UUID!
    image: String
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    order: Int
    question: UUID
    questions: questions
}

type answerConnection {
    edges: [answerEdge!]!
    pageInfo: PageInfo!
}

type answerDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type answerEdge {
    cursor: String!
    node: answer!
}

type answerInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type answerUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type books implements Node {
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    color: String
    created_at: Datetime
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
}

type booksConnection {
    edges: [booksEdge!]!
    pageInfo: PageInfo!
}

type booksDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type booksEdge {
    cursor: String!
    node: books!
}

type booksInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type booksUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type chapters implements Node {
    book: UUID
    books: books
    chapters: chapters
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    created_at: Datetime
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    parent: UUID
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
}

type chaptersConnection {
    edges: [chaptersEdge!]!
    pageInfo: PageInfo!
}

type chaptersDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type chaptersEdge {
    cursor: String!
    node: chapters!
}

type chaptersInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type chaptersUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type chapters_select_state implements Node {
    created_at: Datetime
    email: String
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    state: JSON
    users: users
}

type chapters_select_stateConnection {
    edges: [chapters_select_stateEdge!]!
    pageInfo: PageInfo!
}

type chapters_select_stateDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters_select_state!]!
}

type chapters_select_stateEdge {
    cursor: String!
    node: chapters_select_state!
}

type chapters_select_stateInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters_select_state!]!
}

type chapters_select_stateUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters_select_state!]!
}

type filter_states implements Node {
    category: String
    created_at: Datetime
    email: String
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    state: JSON
    users: users
}

type filter_statesConnection {
    edges: [filter_statesEdge!]!
    pageInfo: PageInfo!
}

type filter_statesDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [filter_states!]!
}

type filter_statesEdge {
    cursor: String!
    node: filter_states!
}

type filter_statesInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [filter_states!]!
}

type filter_statesUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [filter_states!]!
}

type question_images implements Node {
    created_at: Datetime
    id: UUID!
    image: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    order: Int
    question: UUID
    questions: questions
}

type question_imagesConnection {
    edges: [question_imagesEdge!]!
    pageInfo: PageInfo!
}

type question_imagesDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type question_imagesEdge {
    cursor: String!
    node: question_images!
}

type question_imagesInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type question_imagesUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type questions implements Node {
    answerCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: answerFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [answerOrderBy!]
    ): answerConnection
    book: UUID
    books: books
    chapter: UUID
    chapters: chapters
    created_at: Datetime
    description: String
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    question_imagesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: question_imagesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [question_imagesOrderBy!]
    ): question_imagesConnection
}

type questionsConnection {
    edges: [questionsEdge!]!
    pageInfo: PageInfo!
}

type questionsDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type questionsEdge {
    cursor: String!
    node: questions!
}

type questionsInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type questionsUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type user_books_assignation implements Node {
    book: UUID
    books: books
    created_at: Datetime
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    user: UUID
    users: users
}

type user_books_assignationConnection {
    edges: [user_books_assignationEdge!]!
    pageInfo: PageInfo!
}

type user_books_assignationDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type user_books_assignationEdge {
    cursor: String!
    node: user_books_assignation!
}

type user_books_assignationInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type user_books_assignationUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type users implements Node {
    chapters_select_stateCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chapters_select_stateFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chapters_select_stateOrderBy!]
    ): chapters_select_stateConnection
    email: String
    emailVerified: Datetime
    filter_statesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: filter_statesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [filter_statesOrderBy!]
    ): filter_statesConnection
    firstName: String
    id: UUID!
    image: String
    isAdmin: Boolean
    isEnabled: Boolean
    lastName: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
}

type usersConnection {
    edges: [usersEdge!]!
    pageInfo: PageInfo!
}

type usersEdge {
    cursor: String!
    node: users!
}

type usersUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [users!]!
}

enum FilterIs {
    NOT_NULL
    NULL
}

"Defines a per-field sorting order"
enum OrderByDirection {
    "Ascending order, nulls first"
    AscNullsFirst
    "Ascending order, nulls last"
    AscNullsLast
    "Descending order, nulls first"
    DescNullsFirst
    "Descending order, nulls last"
    DescNullsLast
}

"A high precision floating point value represented as a string"
scalar BigFloat

"An arbitrary size integer represented as a string"
scalar BigInt

"An opaque string using for tracking a position in results during pagination"
scalar Cursor

"A date wihout time information"
scalar Date

"A date and time"
scalar Datetime

"A Javascript Object Notation value serialized as a string"
scalar JSON

"Any type not handled by the type system"
scalar Opaque

"A time without date information"
scalar Time

"A universally unique identifier"
scalar UUID

"Boolean expression comparing fields on type \"BigFloat\""
input BigFloatFilter {
    eq: BigFloat
    gt: BigFloat
    gte: BigFloat
    in: [BigFloat!]
    is: FilterIs
    lt: BigFloat
    lte: BigFloat
    neq: BigFloat
}

"Boolean expression comparing fields on type \"BigInt\""
input BigIntFilter {
    eq: BigInt
    gt: BigInt
    gte: BigInt
    in: [BigInt!]
    is: FilterIs
    lt: BigInt
    lte: BigInt
    neq: BigInt
}

"Boolean expression comparing fields on type \"Boolean\""
input BooleanFilter {
    eq: Boolean
    is: FilterIs
}

"Boolean expression comparing fields on type \"Date\""
input DateFilter {
    eq: Date
    gt: Date
    gte: Date
    in: [Date!]
    is: FilterIs
    lt: Date
    lte: Date
    neq: Date
}

"Boolean expression comparing fields on type \"Datetime\""
input DatetimeFilter {
    eq: Datetime
    gt: Datetime
    gte: Datetime
    in: [Datetime!]
    is: FilterIs
    lt: Datetime
    lte: Datetime
    neq: Datetime
}

"Boolean expression comparing fields on type \"Float\""
input FloatFilter {
    eq: Float
    gt: Float
    gte: Float
    in: [Float!]
    is: FilterIs
    lt: Float
    lte: Float
    neq: Float
}

"Boolean expression comparing fields on type \"ID\""
input IDFilter {
    eq: ID
}

"Boolean expression comparing fields on type \"Int\""
input IntFilter {
    eq: Int
    gt: Int
    gte: Int
    in: [Int!]
    is: FilterIs
    lt: Int
    lte: Int
    neq: Int
}

"Boolean expression comparing fields on type \"Opaque\""
input OpaqueFilter {
    eq: Opaque
    is: FilterIs
}

"Boolean expression comparing fields on type \"String\""
input StringFilter {
    eq: String
    gt: String
    gte: String
    ilike: String
    in: [String!]
    is: FilterIs
    like: String
    lt: String
    lte: String
    neq: String
    startsWith: String
}

"Boolean expression comparing fields on type \"Time\""
input TimeFilter {
    eq: Time
    gt: Time
    gte: Time
    in: [Time!]
    is: FilterIs
    lt: Time
    lte: Time
    neq: Time
}

"Boolean expression comparing fields on type \"UUID\""
input UUIDFilter {
    eq: UUID
    in: [UUID!]
    is: FilterIs
    neq: UUID
}

input answerFilter {
    created_at: DatetimeFilter
    id: UUIDFilter
    image: StringFilter
    name: StringFilter
    nodeId: IDFilter
    order: IntFilter
    question: UUIDFilter
}

input answerInsertInput {
    created_at: Datetime
    id: UUID
    image: String
    name: String
    order: Int
    question: UUID
}

input answerOrderBy {
    created_at: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    name: OrderByDirection
    order: OrderByDirection
    question: OrderByDirection
}

input answerUpdateInput {
    created_at: Datetime
    id: UUID
    image: String
    name: String
    order: Int
    question: UUID
}

input booksFilter {
    color: StringFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
}

input booksInsertInput {
    color: String
    created_at: Datetime
    id: UUID
    name: String
}

input booksOrderBy {
    color: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
}

input booksUpdateInput {
    color: String
    created_at: Datetime
    id: UUID
    name: String
}

input chaptersFilter {
    book: UUIDFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
    parent: UUIDFilter
}

input chaptersInsertInput {
    book: UUID
    created_at: Datetime
    id: UUID
    name: String
    parent: UUID
}

input chaptersOrderBy {
    book: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
    parent: OrderByDirection
}

input chaptersUpdateInput {
    book: UUID
    created_at: Datetime
    id: UUID
    name: String
    parent: UUID
}

input chapters_select_stateFilter {
    created_at: DatetimeFilter
    email: StringFilter
    id: UUIDFilter
    nodeId: IDFilter
}

input chapters_select_stateInsertInput {
    created_at: Datetime
    email: String
    id: UUID
    state: JSON
}

input chapters_select_stateOrderBy {
    created_at: OrderByDirection
    email: OrderByDirection
    id: OrderByDirection
}

input chapters_select_stateUpdateInput {
    created_at: Datetime
    email: String
    id: UUID
    state: JSON
}

input filter_statesFilter {
    category: StringFilter
    created_at: DatetimeFilter
    email: StringFilter
    id: UUIDFilter
    nodeId: IDFilter
}

input filter_statesInsertInput {
    category: String
    created_at: Datetime
    email: String
    id: UUID
    state: JSON
}

input filter_statesOrderBy {
    category: OrderByDirection
    created_at: OrderByDirection
    email: OrderByDirection
    id: OrderByDirection
}

input filter_statesUpdateInput {
    category: String
    created_at: Datetime
    email: String
    id: UUID
    state: JSON
}

input question_imagesFilter {
    created_at: DatetimeFilter
    id: UUIDFilter
    image: StringFilter
    nodeId: IDFilter
    order: IntFilter
    question: UUIDFilter
}

input question_imagesInsertInput {
    created_at: Datetime
    id: UUID
    image: String
    order: Int
    question: UUID
}

input question_imagesOrderBy {
    created_at: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    order: OrderByDirection
    question: OrderByDirection
}

input question_imagesUpdateInput {
    created_at: Datetime
    id: UUID
    image: String
    order: Int
    question: UUID
}

input questionsFilter {
    book: UUIDFilter
    chapter: UUIDFilter
    created_at: DatetimeFilter
    description: StringFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
}

input questionsInsertInput {
    book: UUID
    chapter: UUID
    created_at: Datetime
    description: String
    id: UUID
    name: String
}

input questionsOrderBy {
    book: OrderByDirection
    chapter: OrderByDirection
    created_at: OrderByDirection
    description: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
}

input questionsUpdateInput {
    book: UUID
    chapter: UUID
    created_at: Datetime
    description: String
    id: UUID
    name: String
}

input user_books_assignationFilter {
    book: UUIDFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    nodeId: IDFilter
    user: UUIDFilter
}

input user_books_assignationInsertInput {
    book: UUID
    created_at: Datetime
    id: UUID
    user: UUID
}

input user_books_assignationOrderBy {
    book: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    user: OrderByDirection
}

input user_books_assignationUpdateInput {
    book: UUID
    created_at: Datetime
    id: UUID
    user: UUID
}

input usersFilter {
    email: StringFilter
    emailVerified: DatetimeFilter
    firstName: StringFilter
    id: UUIDFilter
    image: StringFilter
    isAdmin: BooleanFilter
    isEnabled: BooleanFilter
    lastName: StringFilter
    nodeId: IDFilter
}

input usersOrderBy {
    email: OrderByDirection
    emailVerified: OrderByDirection
    firstName: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    isAdmin: OrderByDirection
    isEnabled: OrderByDirection
    lastName: OrderByDirection
}

input usersUpdateInput {
    email: String
    emailVerified: Datetime
    firstName: String
    id: UUID
    image: String
    isAdmin: Boolean
    isEnabled: Boolean
    lastName: String
}
