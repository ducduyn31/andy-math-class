# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Node {
    "Retrieves a record by `ID`"
    nodeId: ID!
}

"The root type for creating and mutating data"
type Mutation {
    "Deletes zero or more records from the `accounts` collection"
    deleteFromaccountsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: accountsFilter
    ): accountsDeleteResponse!
    "Deletes zero or more records from the `answer` collection"
    deleteFromanswerCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: answerFilter
    ): answerDeleteResponse!
    "Deletes zero or more records from the `books` collection"
    deleteFrombooksCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: booksFilter
    ): booksDeleteResponse!
    "Deletes zero or more records from the `chapters` collection"
    deleteFromchaptersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chaptersFilter
    ): chaptersDeleteResponse!
    "Deletes zero or more records from the `question_images` collection"
    deleteFromquestion_imagesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: question_imagesFilter
    ): question_imagesDeleteResponse!
    "Deletes zero or more records from the `questions` collection"
    deleteFromquestionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: questionsFilter
    ): questionsDeleteResponse!
    "Deletes zero or more records from the `sessions` collection"
    deleteFromsessionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: sessionsFilter
    ): sessionsDeleteResponse!
    "Deletes zero or more records from the `user_books_assignation` collection"
    deleteFromuser_books_assignationCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: user_books_assignationFilter
    ): user_books_assignationDeleteResponse!
    "Deletes zero or more records from the `users` collection"
    deleteFromusersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: usersFilter
    ): usersDeleteResponse!
    "Deletes zero or more records from the `verification_tokens` collection"
    deleteFromverification_tokensCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: verification_tokensFilter
    ): verification_tokensDeleteResponse!
    "Adds one or more `accounts` records to the collection"
    insertIntoaccountsCollection(objects: [accountsInsertInput!]!): accountsInsertResponse
    "Adds one or more `answer` records to the collection"
    insertIntoanswerCollection(objects: [answerInsertInput!]!): answerInsertResponse
    "Adds one or more `books` records to the collection"
    insertIntobooksCollection(objects: [booksInsertInput!]!): booksInsertResponse
    "Adds one or more `chapters` records to the collection"
    insertIntochaptersCollection(objects: [chaptersInsertInput!]!): chaptersInsertResponse
    "Adds one or more `question_images` records to the collection"
    insertIntoquestion_imagesCollection(objects: [question_imagesInsertInput!]!): question_imagesInsertResponse
    "Adds one or more `questions` records to the collection"
    insertIntoquestionsCollection(objects: [questionsInsertInput!]!): questionsInsertResponse
    "Adds one or more `sessions` records to the collection"
    insertIntosessionsCollection(objects: [sessionsInsertInput!]!): sessionsInsertResponse
    "Adds one or more `user_books_assignation` records to the collection"
    insertIntouser_books_assignationCollection(objects: [user_books_assignationInsertInput!]!): user_books_assignationInsertResponse
    "Adds one or more `users` records to the collection"
    insertIntousersCollection(objects: [usersInsertInput!]!): usersInsertResponse
    "Adds one or more `verification_tokens` records to the collection"
    insertIntoverification_tokensCollection(objects: [verification_tokensInsertInput!]!): verification_tokensInsertResponse
    "Updates zero or more records in the `accounts` collection"
    updateaccountsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: accountsFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: accountsUpdateInput!
    ): accountsUpdateResponse!
    "Updates zero or more records in the `answer` collection"
    updateanswerCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: answerFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: answerUpdateInput!
    ): answerUpdateResponse!
    "Updates zero or more records in the `books` collection"
    updatebooksCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: booksFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: booksUpdateInput!
    ): booksUpdateResponse!
    "Updates zero or more records in the `chapters` collection"
    updatechaptersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: chaptersFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: chaptersUpdateInput!
    ): chaptersUpdateResponse!
    "Updates zero or more records in the `question_images` collection"
    updatequestion_imagesCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: question_imagesFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: question_imagesUpdateInput!
    ): question_imagesUpdateResponse!
    "Updates zero or more records in the `questions` collection"
    updatequestionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: questionsFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: questionsUpdateInput!
    ): questionsUpdateResponse!
    "Updates zero or more records in the `sessions` collection"
    updatesessionsCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: sessionsFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: sessionsUpdateInput!
    ): sessionsUpdateResponse!
    "Updates zero or more records in the `user_books_assignation` collection"
    updateuser_books_assignationCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: user_books_assignationFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: user_books_assignationUpdateInput!
    ): user_books_assignationUpdateResponse!
    "Updates zero or more records in the `users` collection"
    updateusersCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: usersFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: usersUpdateInput!
    ): usersUpdateResponse!
    "Updates zero or more records in the `verification_tokens` collection"
    updateverification_tokensCollection(
        "The maximum number of records in the collection permitted to be affected"
        atMost: Int! = 1,
        "Restricts the mutation's impact to records matching the criteria"
        filter: verification_tokensFilter,
        "Fields that are set will be updated for all records matching the `filter`"
        set: verification_tokensUpdateInput!
    ): verification_tokensUpdateResponse!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

"The root type for querying data"
type Query {
    "A pagable collection of type `accounts`"
    accountsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: accountsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [accountsOrderBy!]
    ): accountsConnection
    "A pagable collection of type `answer`"
    answerCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: answerFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [answerOrderBy!]
    ): answerConnection
    "A pagable collection of type `books`"
    booksCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: booksFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [booksOrderBy!]
    ): booksConnection
    "A pagable collection of type `chapters`"
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    "Retrieve a record by its `ID`"
    node(
        "The record's `ID`"
        nodeId: ID!
    ): Node
    "A pagable collection of type `question_images`"
    question_imagesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: question_imagesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [question_imagesOrderBy!]
    ): question_imagesConnection
    "A pagable collection of type `questions`"
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
    "A pagable collection of type `sessions`"
    sessionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: sessionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [sessionsOrderBy!]
    ): sessionsConnection
    "A pagable collection of type `user_books_assignation`"
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
    "A pagable collection of type `users`"
    usersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: usersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [usersOrderBy!]
    ): usersConnection
    "A pagable collection of type `verification_tokens`"
    verification_tokensCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: verification_tokensFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [verification_tokensOrderBy!]
    ): verification_tokensConnection
}

type accounts implements Node {
    access_token: String
    expires_at: BigInt
    id: UUID!
    id_token: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    oauth_token: String
    oauth_token_secret: String
    provider: String!
    providerAccountId: String!
    refresh_token: String
    scope: String
    session_state: String
    token_type: String
    type: String!
    user: users
    userId: UUID
}

type accountsConnection {
    edges: [accountsEdge!]!
    pageInfo: PageInfo!
}

type accountsDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [accounts!]!
}

type accountsEdge {
    cursor: String!
    node: accounts!
}

type accountsInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [accounts!]!
}

type accountsUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [accounts!]!
}

type answer implements Node {
    created_at: Datetime
    id: UUID!
    image: String
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    order: Int
    question: UUID
    questions: questions
}

type answerConnection {
    edges: [answerEdge!]!
    pageInfo: PageInfo!
}

type answerDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type answerEdge {
    cursor: String!
    node: answer!
}

type answerInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type answerUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [answer!]!
}

type books implements Node {
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    color: String
    created_at: Datetime
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
}

type booksConnection {
    edges: [booksEdge!]!
    pageInfo: PageInfo!
}

type booksDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type booksEdge {
    cursor: String!
    node: books!
}

type booksInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type booksUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [books!]!
}

type chapters implements Node {
    book: UUID
    books: books
    chapters: chapters
    chaptersCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: chaptersFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [chaptersOrderBy!]
    ): chaptersConnection
    created_at: Datetime
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    parent: UUID
    questionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: questionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [questionsOrderBy!]
    ): questionsConnection
}

type chaptersConnection {
    edges: [chaptersEdge!]!
    pageInfo: PageInfo!
}

type chaptersDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type chaptersEdge {
    cursor: String!
    node: chapters!
}

type chaptersInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type chaptersUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [chapters!]!
}

type question_images implements Node {
    created_at: Datetime
    id: UUID!
    image: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    order: Int
    question: UUID
    questions: questions
}

type question_imagesConnection {
    edges: [question_imagesEdge!]!
    pageInfo: PageInfo!
}

type question_imagesDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type question_imagesEdge {
    cursor: String!
    node: question_images!
}

type question_imagesInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type question_imagesUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [question_images!]!
}

type questions implements Node {
    answerCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: answerFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [answerOrderBy!]
    ): answerConnection
    book: UUID
    books: books
    chapter: UUID
    chapters: chapters
    created_at: Datetime
    description: String
    id: UUID!
    name: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    question_imagesCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: question_imagesFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [question_imagesOrderBy!]
    ): question_imagesConnection
}

type questionsConnection {
    edges: [questionsEdge!]!
    pageInfo: PageInfo!
}

type questionsDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type questionsEdge {
    cursor: String!
    node: questions!
}

type questionsInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type questionsUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [questions!]!
}

type sessions implements Node {
    expires: Datetime!
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    sessionToken: String!
    user: users
    userId: UUID
}

type sessionsConnection {
    edges: [sessionsEdge!]!
    pageInfo: PageInfo!
}

type sessionsDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [sessions!]!
}

type sessionsEdge {
    cursor: String!
    node: sessions!
}

type sessionsInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [sessions!]!
}

type sessionsUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [sessions!]!
}

type user_books_assignation implements Node {
    book: UUID
    books: books
    created_at: Datetime
    id: UUID!
    "Globally Unique Record Identifier"
    nodeId: ID!
    user: UUID
    users: users
}

type user_books_assignationConnection {
    edges: [user_books_assignationEdge!]!
    pageInfo: PageInfo!
}

type user_books_assignationDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type user_books_assignationEdge {
    cursor: String!
    node: user_books_assignation!
}

type user_books_assignationInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type user_books_assignationUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [user_books_assignation!]!
}

type users implements Node {
    accountsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: accountsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [accountsOrderBy!]
    ): accountsConnection
    email: String
    emailVerified: Datetime
    firstName: String
    id: UUID!
    image: String
    isAdmin: Boolean
    isEnabled: Boolean
    lastName: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    sessionsCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: sessionsFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [sessionsOrderBy!]
    ): sessionsConnection
    user_books_assignationCollection(
        "Query values in the collection after the provided cursor"
        after: Cursor,
        "Query values in the collection before the provided cursor"
        before: Cursor,
        "Filters to apply to the results set when querying from the collection"
        filter: user_books_assignationFilter,
        "Query the first `n` records in the collection"
        first: Int,
        "Query the last `n` records in the collection"
        last: Int,
        "Sort order to apply to the collection"
        orderBy: [user_books_assignationOrderBy!]
    ): user_books_assignationConnection
}

type usersConnection {
    edges: [usersEdge!]!
    pageInfo: PageInfo!
}

type usersDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [users!]!
}

type usersEdge {
    cursor: String!
    node: users!
}

type usersInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [users!]!
}

type usersUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [users!]!
}

type verification_tokens implements Node {
    expires: Datetime!
    identifier: String
    "Globally Unique Record Identifier"
    nodeId: ID!
    token: String!
}

type verification_tokensConnection {
    edges: [verification_tokensEdge!]!
    pageInfo: PageInfo!
}

type verification_tokensDeleteResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [verification_tokens!]!
}

type verification_tokensEdge {
    cursor: String!
    node: verification_tokens!
}

type verification_tokensInsertResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [verification_tokens!]!
}

type verification_tokensUpdateResponse {
    "Count of the records impacted by the mutation"
    affectedCount: Int!
    "Array of records impacted by the mutation"
    records: [verification_tokens!]!
}

enum FilterIs {
    NOT_NULL
    NULL
}

"Defines a per-field sorting order"
enum OrderByDirection {
    "Ascending order, nulls first"
    AscNullsFirst
    "Ascending order, nulls last"
    AscNullsLast
    "Descending order, nulls first"
    DescNullsFirst
    "Descending order, nulls last"
    DescNullsLast
}

"A high precision floating point value represented as a string"
scalar BigFloat

"An arbitrary size integer represented as a string"
scalar BigInt

"An opaque string using for tracking a position in results during pagination"
scalar Cursor

"A date wihout time information"
scalar Date

"A date and time"
scalar Datetime

"A Javascript Object Notation value serialized as a string"
scalar JSON

"Any type not handled by the type system"
scalar Opaque

"A time without date information"
scalar Time

"A universally unique identifier"
scalar UUID

"Boolean expression comparing fields on type \"BigFloat\""
input BigFloatFilter {
    eq: BigFloat
    gt: BigFloat
    gte: BigFloat
    in: [BigFloat!]
    is: FilterIs
    lt: BigFloat
    lte: BigFloat
    neq: BigFloat
}

"Boolean expression comparing fields on type \"BigInt\""
input BigIntFilter {
    eq: BigInt
    gt: BigInt
    gte: BigInt
    in: [BigInt!]
    is: FilterIs
    lt: BigInt
    lte: BigInt
    neq: BigInt
}

"Boolean expression comparing fields on type \"Boolean\""
input BooleanFilter {
    eq: Boolean
    is: FilterIs
}

"Boolean expression comparing fields on type \"Date\""
input DateFilter {
    eq: Date
    gt: Date
    gte: Date
    in: [Date!]
    is: FilterIs
    lt: Date
    lte: Date
    neq: Date
}

"Boolean expression comparing fields on type \"Datetime\""
input DatetimeFilter {
    eq: Datetime
    gt: Datetime
    gte: Datetime
    in: [Datetime!]
    is: FilterIs
    lt: Datetime
    lte: Datetime
    neq: Datetime
}

"Boolean expression comparing fields on type \"Float\""
input FloatFilter {
    eq: Float
    gt: Float
    gte: Float
    in: [Float!]
    is: FilterIs
    lt: Float
    lte: Float
    neq: Float
}

"Boolean expression comparing fields on type \"ID\""
input IDFilter {
    eq: ID
}

"Boolean expression comparing fields on type \"Int\""
input IntFilter {
    eq: Int
    gt: Int
    gte: Int
    in: [Int!]
    is: FilterIs
    lt: Int
    lte: Int
    neq: Int
}

"Boolean expression comparing fields on type \"Opaque\""
input OpaqueFilter {
    eq: Opaque
    is: FilterIs
}

"Boolean expression comparing fields on type \"String\""
input StringFilter {
    eq: String
    gt: String
    gte: String
    ilike: String
    in: [String!]
    is: FilterIs
    like: String
    lt: String
    lte: String
    neq: String
    startsWith: String
}

"Boolean expression comparing fields on type \"Time\""
input TimeFilter {
    eq: Time
    gt: Time
    gte: Time
    in: [Time!]
    is: FilterIs
    lt: Time
    lte: Time
    neq: Time
}

"Boolean expression comparing fields on type \"UUID\""
input UUIDFilter {
    eq: UUID
    in: [UUID!]
    is: FilterIs
    neq: UUID
}

input accountsFilter {
    access_token: StringFilter
    expires_at: BigIntFilter
    id: UUIDFilter
    id_token: StringFilter
    nodeId: IDFilter
    oauth_token: StringFilter
    oauth_token_secret: StringFilter
    provider: StringFilter
    providerAccountId: StringFilter
    refresh_token: StringFilter
    scope: StringFilter
    session_state: StringFilter
    token_type: StringFilter
    type: StringFilter
    userId: UUIDFilter
}

input accountsInsertInput {
    access_token: String
    expires_at: BigInt
    id: UUID
    id_token: String
    oauth_token: String
    oauth_token_secret: String
    provider: String
    providerAccountId: String
    refresh_token: String
    scope: String
    session_state: String
    token_type: String
    type: String
    userId: UUID
}

input accountsOrderBy {
    access_token: OrderByDirection
    expires_at: OrderByDirection
    id: OrderByDirection
    id_token: OrderByDirection
    oauth_token: OrderByDirection
    oauth_token_secret: OrderByDirection
    provider: OrderByDirection
    providerAccountId: OrderByDirection
    refresh_token: OrderByDirection
    scope: OrderByDirection
    session_state: OrderByDirection
    token_type: OrderByDirection
    type: OrderByDirection
    userId: OrderByDirection
}

input accountsUpdateInput {
    access_token: String
    expires_at: BigInt
    id: UUID
    id_token: String
    oauth_token: String
    oauth_token_secret: String
    provider: String
    providerAccountId: String
    refresh_token: String
    scope: String
    session_state: String
    token_type: String
    type: String
    userId: UUID
}

input answerFilter {
    created_at: DatetimeFilter
    id: UUIDFilter
    image: StringFilter
    name: StringFilter
    nodeId: IDFilter
    order: IntFilter
    question: UUIDFilter
}

input answerInsertInput {
    created_at: Datetime
    id: UUID
    image: String
    name: String
    order: Int
    question: UUID
}

input answerOrderBy {
    created_at: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    name: OrderByDirection
    order: OrderByDirection
    question: OrderByDirection
}

input answerUpdateInput {
    created_at: Datetime
    id: UUID
    image: String
    name: String
    order: Int
    question: UUID
}

input booksFilter {
    color: StringFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
}

input booksInsertInput {
    color: String
    created_at: Datetime
    id: UUID
    name: String
}

input booksOrderBy {
    color: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
}

input booksUpdateInput {
    color: String
    created_at: Datetime
    id: UUID
    name: String
}

input chaptersFilter {
    book: UUIDFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
    parent: UUIDFilter
}

input chaptersInsertInput {
    book: UUID
    created_at: Datetime
    id: UUID
    name: String
    parent: UUID
}

input chaptersOrderBy {
    book: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
    parent: OrderByDirection
}

input chaptersUpdateInput {
    book: UUID
    created_at: Datetime
    id: UUID
    name: String
    parent: UUID
}

input question_imagesFilter {
    created_at: DatetimeFilter
    id: UUIDFilter
    image: StringFilter
    nodeId: IDFilter
    order: IntFilter
    question: UUIDFilter
}

input question_imagesInsertInput {
    created_at: Datetime
    id: UUID
    image: String
    order: Int
    question: UUID
}

input question_imagesOrderBy {
    created_at: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    order: OrderByDirection
    question: OrderByDirection
}

input question_imagesUpdateInput {
    created_at: Datetime
    id: UUID
    image: String
    order: Int
    question: UUID
}

input questionsFilter {
    book: UUIDFilter
    chapter: UUIDFilter
    created_at: DatetimeFilter
    description: StringFilter
    id: UUIDFilter
    name: StringFilter
    nodeId: IDFilter
}

input questionsInsertInput {
    book: UUID
    chapter: UUID
    created_at: Datetime
    description: String
    id: UUID
    name: String
}

input questionsOrderBy {
    book: OrderByDirection
    chapter: OrderByDirection
    created_at: OrderByDirection
    description: OrderByDirection
    id: OrderByDirection
    name: OrderByDirection
}

input questionsUpdateInput {
    book: UUID
    chapter: UUID
    created_at: Datetime
    description: String
    id: UUID
    name: String
}

input sessionsFilter {
    expires: DatetimeFilter
    id: UUIDFilter
    nodeId: IDFilter
    sessionToken: StringFilter
    userId: UUIDFilter
}

input sessionsInsertInput {
    expires: Datetime
    id: UUID
    sessionToken: String
    userId: UUID
}

input sessionsOrderBy {
    expires: OrderByDirection
    id: OrderByDirection
    sessionToken: OrderByDirection
    userId: OrderByDirection
}

input sessionsUpdateInput {
    expires: Datetime
    id: UUID
    sessionToken: String
    userId: UUID
}

input user_books_assignationFilter {
    book: UUIDFilter
    created_at: DatetimeFilter
    id: UUIDFilter
    nodeId: IDFilter
    user: UUIDFilter
}

input user_books_assignationInsertInput {
    book: UUID
    created_at: Datetime
    id: UUID
    user: UUID
}

input user_books_assignationOrderBy {
    book: OrderByDirection
    created_at: OrderByDirection
    id: OrderByDirection
    user: OrderByDirection
}

input user_books_assignationUpdateInput {
    book: UUID
    created_at: Datetime
    id: UUID
    user: UUID
}

input usersFilter {
    email: StringFilter
    emailVerified: DatetimeFilter
    firstName: StringFilter
    id: UUIDFilter
    image: StringFilter
    isAdmin: BooleanFilter
    isEnabled: BooleanFilter
    lastName: StringFilter
    nodeId: IDFilter
}

input usersInsertInput {
    email: String
    emailVerified: Datetime
    firstName: String
    id: UUID
    image: String
    isAdmin: Boolean
    isEnabled: Boolean
    lastName: String
}

input usersOrderBy {
    email: OrderByDirection
    emailVerified: OrderByDirection
    firstName: OrderByDirection
    id: OrderByDirection
    image: OrderByDirection
    isAdmin: OrderByDirection
    isEnabled: OrderByDirection
    lastName: OrderByDirection
}

input usersUpdateInput {
    email: String
    emailVerified: Datetime
    firstName: String
    id: UUID
    image: String
    isAdmin: Boolean
    isEnabled: Boolean
    lastName: String
}

input verification_tokensFilter {
    expires: DatetimeFilter
    identifier: StringFilter
    nodeId: IDFilter
    token: StringFilter
}

input verification_tokensInsertInput {
    expires: Datetime
    identifier: String
    token: String
}

input verification_tokensOrderBy {
    expires: OrderByDirection
    identifier: OrderByDirection
    token: OrderByDirection
}

input verification_tokensUpdateInput {
    expires: Datetime
    identifier: String
    token: String
}
